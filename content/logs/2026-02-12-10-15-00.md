---
date: 2026-02-12-10-15-00
type: daily-log
summary: "Understanding TypeScript generics and advanced type patterns"
topics: ["typescript", "generics", "type-system"]
ai_generated: true
---

# 2026-02-12-10-15-00

## Conversation: TypeScript Generics Mastery

### Initial Question
**User:** I keep seeing generics in TypeScript but I don't really understand when or why to use them. Can you explain?

**AI:** Generics are one of TypeScript's most powerful features! Think of them as "type variables" that let you write reusable code that works with multiple types.

**Without generics:**
```typescript
function getFirstString(arr: string[]): string {
  return arr[0];
}

function getFirstNumber(arr: number[]): number {
  return arr[0];
}

// Need separate function for each type!
```

**With generics:**
```typescript
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

const firstString = getFirst(['a', 'b', 'c']); // string
const firstNumber = getFirst([1, 2, 3]); // number
const firstUser = getFirst([{ name: 'Alice' }]); // { name: string }
```

The `<T>` is a type parameter - it's like a placeholder that gets filled in when you use the function.

### Follow-up Question
**User:** Okay, that makes sense. But what about more complex scenarios?

**AI:** Great! Let's explore some real-world patterns:

**1. API Response Wrapper:**
```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// Now you can type any API response
const userResponse: ApiResponse<User> = {
  data: { id: 1, name: 'Alice' },
  status: 200,
  message: 'Success'
};

const postsResponse: ApiResponse<Post[]> = {
  data: [{ id: 1, title: 'Hello' }],
  status: 200,
  message: 'Success'
};
```

**2. Generic Fetch Function:**
```typescript
async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  const response = await fetch(url);
  return response.json();
}

// TypeScript knows the exact return type!
const users = await fetchData<User[]>('/api/users');
// users.data is User[]

const post = await fetchData<Post>('/api/posts/1');
// post.data is Post
```

**3. Generic Component (React):**
```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <div>
      {items.map(item => (
        <div key={keyExtractor(item)}>
          {renderItem(item)}
        </div>
      ))}
    </div>
  );
}

// Usage with full type safety
<List
  items={users}
  renderItem={(user) => <div>{user.name}</div>}
  keyExtractor={(user) => user.id.toString()}
/>
```

### Advanced Question
**User:** What about generic constraints? I've seen `extends` used with generics.

**AI:** Excellent question! Constraints let you specify that a generic type must have certain properties.

**Basic constraint:**
```typescript
interface HasId {
  id: number;
}

function findById<T extends HasId>(items: T[], id: number): T | undefined {
  return items.find(item => item.id === id);
}

// Works with any type that has an id
const user = findById(users, 1); // User | undefined
const post = findById(posts, 1); // Post | undefined

// Error: number doesn't have id property
// findById([1, 2, 3], 1);
```

**Multiple constraints:**
```typescript
interface Nameable {
  name: string;
}

interface Timestamped {
  createdAt: Date;
}

function sortByName<T extends Nameable & Timestamped>(items: T[]): T[] {
  return items.sort((a, b) => a.name.localeCompare(b.name));
}
```

**keyof constraint:**
```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: 'Alice', age: 30 };
const name = getProperty(user, 'name'); // string
const age = getProperty(user, 'age'); // number

// Error: 'email' doesn't exist on user
// getProperty(user, 'email');
```

### Practical Pattern Question
**User:** Can you show me how to build a type-safe event emitter with generics?

**AI:** Absolutely! This is a great real-world example:

```typescript
type EventMap = {
  [key: string]: any;
};

class TypedEventEmitter<Events extends EventMap> {
  private listeners: {
    [K in keyof Events]?: Array<(data: Events[K]) => void>;
  } = {};

  on<K extends keyof Events>(
    event: K,
    listener: (data: Events[K]) => void
  ): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }

  emit<K extends keyof Events>(event: K, data: Events[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }

  off<K extends keyof Events>(
    event: K,
    listener: (data: Events[K]) => void
  ): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      this.listeners[event] = eventListeners.filter(l => l !== listener);
    }
  }
}

// Define your events
interface AppEvents {
  userLogin: { userId: number; timestamp: Date };
  userLogout: { userId: number };
  messageReceived: { from: string; content: string };
  error: { code: number; message: string };
}

// Create typed emitter
const emitter = new TypedEventEmitter<AppEvents>();

// Full type safety!
emitter.on('userLogin', (data) => {
  console.log(data.userId); // TypeScript knows this exists
  console.log(data.timestamp); // And this too
});

emitter.emit('userLogin', {
  userId: 123,
  timestamp: new Date()
}); // ✓ Correct

// Error: wrong data shape
// emitter.emit('userLogin', { userId: 123 });

// Error: event doesn't exist
// emitter.on('unknownEvent', () => {});
```

### Complex Pattern Question
**User:** Wow! Can you show me how to create a type-safe form builder?

**AI:** Sure! This combines multiple advanced TypeScript features:

```typescript
type FormField = {
  type: 'text' | 'number' | 'email' | 'checkbox';
  label: string;
  required?: boolean;
};

type FormSchema = {
  [key: string]: FormField;
};

// Extract form values type from schema
type FormValues<T extends FormSchema> = {
  [K in keyof T]: T[K]['type'] extends 'checkbox'
    ? boolean
    : T[K]['type'] extends 'number'
    ? number
    : string;
};

// Extract error type
type FormErrors<T extends FormSchema> = {
  [K in keyof T]?: string;
};

class FormBuilder<T extends FormSchema> {
  private schema: T;
  private values: Partial<FormValues<T>> = {};
  private errors: FormErrors<T> = {};

  constructor(schema: T) {
    this.schema = schema;
  }

  setValue<K extends keyof T>(
    field: K,
    value: FormValues<T>[K]
  ): void {
    this.values[field] = value;
    this.errors[field] = undefined;
  }

  getValue<K extends keyof T>(field: K): FormValues<T>[K] | undefined {
    return this.values[field];
  }

  validate(): boolean {
    let isValid = true;

    for (const field in this.schema) {
      const fieldSchema = this.schema[field];
      const value = this.values[field];

      if (fieldSchema.required && !value) {
        this.errors[field] = `${fieldSchema.label} is required`;
        isValid = false;
      }
    }

    return isValid;
  }

  getValues(): FormValues<T> {
    return this.values as FormValues<T>;
  }

  getErrors(): FormErrors<T> {
    return this.errors;
  }
}

// Usage
const loginFormSchema = {
  email: { type: 'email' as const, label: 'Email', required: true },
  password: { type: 'text' as const, label: 'Password', required: true },
  rememberMe: { type: 'checkbox' as const, label: 'Remember Me' }
};

const form = new FormBuilder(loginFormSchema);

// Type-safe!
form.setValue('email', 'user@example.com'); // ✓
form.setValue('rememberMe', true); // ✓

// Error: wrong type
// form.setValue('email', 123);

// Error: field doesn't exist
// form.setValue('username', 'test');

if (form.validate()) {
  const values = form.getValues();
  // values is { email: string; password: string; rememberMe: boolean }
  console.log(values.email); // string
  console.log(values.rememberMe); // boolean
}
```

### Utility Types Question
**User:** This is amazing! Are there built-in utility types that use generics?

**AI:** Yes! TypeScript has many powerful utility types:

**1. Partial - Make all properties optional:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string; }

function updateUser(id: number, updates: Partial<User>) {
  // Can update any subset of properties
}
```

**2. Pick - Select specific properties:**
```typescript
type UserPreview = Pick<User, 'id' | 'name'>;
// { id: number; name: string; }
```

**3. Omit - Exclude properties:**
```typescript
type UserWithoutId = Omit<User, 'id'>;
// { name: string; email: string; }
```

**4. Record - Create object type:**
```typescript
type UserRoles = Record<string, string[]>;
// { [key: string]: string[] }

const roles: UserRoles = {
  admin: ['read', 'write', 'delete'],
  user: ['read']
};
```

**5. ReturnType - Extract return type:**
```typescript
function getUser() {
  return { id: 1, name: 'Alice' };
}

type User = ReturnType<typeof getUser>;
// { id: number; name: string; }
```

**6. Awaited - Unwrap Promise:**
```typescript
type Response = Awaited<Promise<User>>;
// User
```

### Key Takeaways

1. Generics enable type-safe reusable code
2. Use constraints (`extends`) to ensure type properties
3. `keyof` creates union of object keys
4. Mapped types transform object types
5. Conditional types enable advanced patterns
6. Built-in utility types solve common problems
7. Generics work with functions, classes, and interfaces

### Related Topics
- Conditional types with `infer`
- Template literal types
- Discriminated unions
- Type guards and narrowing

> This log was automatically generated from a conversation session.
