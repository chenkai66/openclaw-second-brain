---
date: 2026-02-13-14-30-00
type: daily-log
summary: "Deep dive into React hooks and state management patterns"
topics: ["react", "hooks", "state-management"]
ai_generated: true
---

# 2026-02-13-14-30-00

## Conversation: React Hooks Deep Dive

### Initial Question
**User:** I'm confused about when to use useState vs useReducer. Can you explain the differences?

**AI:** Great question! Both manage state, but they serve different purposes:

**useState** is best for:
- Simple state (strings, numbers, booleans)
- Independent state variables
- State with simple update logic

```javascript
const [count, setCount] = useState(0);
const [name, setName] = useState('');
```

**useReducer** is better for:
- Complex state objects
- State with multiple sub-values
- State transitions that depend on previous state
- Complex update logic

```javascript
const [state, dispatch] = useReducer(reducer, initialState);

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}
```

### Follow-up Question
**User:** Can you show me a real-world example where useReducer is clearly better?

**AI:** Absolutely! Let's look at a form with validation:

```javascript
// With useState - gets messy quickly
const [username, setUsername] = useState('');
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const [errors, setErrors] = useState({});
const [isSubmitting, setIsSubmitting] = useState(false);
const [submitError, setSubmitError] = useState(null);

// With useReducer - much cleaner
const initialState = {
  values: { username: '', email: '', password: '' },
  errors: {},
  isSubmitting: false,
  submitError: null
};

function formReducer(state, action) {
  switch (action.type) {
    case 'FIELD_CHANGE':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value },
        errors: { ...state.errors, [action.field]: null }
      };
    case 'VALIDATION_ERROR':
      return { ...state, errors: action.errors };
    case 'SUBMIT_START':
      return { ...state, isSubmitting: true, submitError: null };
    case 'SUBMIT_SUCCESS':
      return { ...initialState };
    case 'SUBMIT_ERROR':
      return { ...state, isSubmitting: false, submitError: action.error };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(formReducer, initialState);

// Usage
<input
  value={state.values.username}
  onChange={(e) => dispatch({ 
    type: 'FIELD_CHANGE', 
    field: 'username', 
    value: e.target.value 
  })}
/>
```

### Deep Dive Question
**User:** What about useContext? When should I combine it with useReducer?

**AI:** Excellent question! Combining useContext + useReducer creates a powerful state management pattern, similar to Redux but simpler.

**When to use this pattern:**
- State needs to be shared across many components
- You want to avoid prop drilling
- State logic is complex enough to benefit from a reducer

**Implementation:**

```javascript
// 1. Create context
const StateContext = createContext();
const DispatchContext = createContext();

// 2. Create provider
function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

// 3. Create custom hooks
function useAppState() {
  const context = useContext(StateContext);
  if (!context) {
    throw new Error('useAppState must be used within AppProvider');
  }
  return context;
}

function useAppDispatch() {
  const context = useContext(DispatchContext);
  if (!context) {
    throw new Error('useAppDispatch must be used within AppProvider');
  }
  return context;
}

// 4. Use in components
function UserProfile() {
  const { user } = useAppState();
  const dispatch = useAppDispatch();
  
  const logout = () => {
    dispatch({ type: 'LOGOUT' });
  };
  
  return <div>{user.name}</div>;
}
```

**Why separate contexts?**
- Performance optimization
- Components using only dispatch won't re-render when state changes
- Components using only state won't get unnecessary dispatch updates

### Performance Question
**User:** How do I prevent unnecessary re-renders with hooks?

**AI:** Great performance question! Here are the key techniques:

**1. React.memo for components:**
```javascript
const ExpensiveComponent = React.memo(({ data }) => {
  console.log('Rendering ExpensiveComponent');
  return <div>{data}</div>;
});
```

**2. useMemo for expensive calculations:**
```javascript
const sortedData = useMemo(() => {
  console.log('Sorting data...');
  return data.sort((a, b) => a.value - b.value);
}, [data]); // Only recalculate when data changes
```

**3. useCallback for function stability:**
```javascript
const handleClick = useCallback(() => {
  console.log('Clicked', id);
}, [id]); // Function only recreated when id changes

// Pass to memoized child
<ExpensiveChild onClick={handleClick} />
```

**4. Split state to minimize re-renders:**
```javascript
// Bad: Everything re-renders when anything changes
const [state, setState] = useState({ user, posts, comments });

// Good: Only affected components re-render
const [user, setUser] = useState();
const [posts, setPosts] = useState([]);
const [comments, setComments] = useState([]);
```

### Practical Example
**User:** Can you show me a complete example with all these concepts?

**AI:** Sure! Here's a todo app with optimized performance:

```javascript
// TodoContext.js
const TodoContext = createContext();

const todoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.id);
    default:
      return state;
  }
};

export function TodoProvider({ children }) {
  const [todos, dispatch] = useReducer(todoReducer, []);
  
  return (
    <TodoContext.Provider value={{ todos, dispatch }}>
      {children}
    </TodoContext.Provider>
  );
}

export const useTodos = () => useContext(TodoContext);

// TodoList.js
const TodoItem = React.memo(({ todo, onToggle, onDelete }) => {
  console.log('Rendering TodoItem', todo.id);
  
  return (
    <div>
      <input
        type="checkbox"
        checked={todo.done}
        onChange={() => onToggle(todo.id)}
      />
      <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </div>
  );
});

function TodoList() {
  const { todos, dispatch } = useTodos();
  
  const handleToggle = useCallback((id) => {
    dispatch({ type: 'TOGGLE_TODO', id });
  }, [dispatch]);
  
  const handleDelete = useCallback((id) => {
    dispatch({ type: 'DELETE_TODO', id });
  }, [dispatch]);
  
  const completedCount = useMemo(() => {
    return todos.filter(t => t.done).length;
  }, [todos]);
  
  return (
    <div>
      <p>Completed: {completedCount} / {todos.length}</p>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}

// AddTodo.js
function AddTodo() {
  const [text, setText] = useState('');
  const { dispatch } = useTodos();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      dispatch({ type: 'ADD_TODO', text });
      setText('');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add todo..."
      />
      <button type="submit">Add</button>
    </form>
  );
}
```

### Key Takeaways

1. **useState** for simple state, **useReducer** for complex state logic
2. **useContext + useReducer** creates powerful global state management
3. **React.memo** prevents component re-renders
4. **useMemo** caches expensive calculations
5. **useCallback** stabilizes function references
6. Split contexts for better performance
7. Always measure before optimizing

### Related Topics
- Custom hooks for reusable logic
- useEffect cleanup and dependencies
- Server state vs client state (React Query)
- State machines with XState

> This log was automatically generated from a conversation session.
