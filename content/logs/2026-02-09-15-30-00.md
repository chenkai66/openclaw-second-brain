---
date: 2026-02-09-15-30-00
type: daily-log
summary: "Understanding API design principles and RESTful best practices"
topics: ["api", "rest", "backend", "design"]
ai_generated: true
---

# 2026-02-09-15-30-00

## Conversation: RESTful API Design Best Practices

### Initial Question
**User:** I'm building my first API. What are the key principles I should follow?

**AI:** Great question! Building a well-designed API is crucial. Here are the core principles:

**1. Use HTTP methods correctly:**
```
GET    - Retrieve resources (safe, idempotent)
POST   - Create new resources
PUT    - Update entire resource (idempotent)
PATCH  - Partial update
DELETE - Remove resource (idempotent)
```

**2. Resource-based URLs:**
```
Good:
GET    /api/users          - Get all users
GET    /api/users/123      - Get user 123
POST   /api/users          - Create user
PUT    /api/users/123      - Update user 123
DELETE /api/users/123      - Delete user 123

Bad:
GET    /api/getUsers
POST   /api/createUser
GET    /api/user?action=delete&id=123
```

**3. Use proper status codes:**
```
200 OK              - Success
201 Created         - Resource created
204 No Content      - Success, no response body
400 Bad Request     - Invalid input
401 Unauthorized    - Authentication required
403 Forbidden       - Authenticated but no permission
404 Not Found       - Resource doesn't exist
500 Internal Error  - Server error
```

**4. Consistent response format:**
```json
{
  "data": { ... },
  "meta": {
    "page": 1,
    "total": 100
  },
  "error": null
}
```

### Follow-up Question
**User:** Can you show me a complete example with Node.js/Express?

**AI:** Absolutely! Here's a well-structured API:

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');

// GET /api/users - List users with pagination
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, sort = 'createdAt', order = 'desc' } = req.query;
    
    const users = await User.find()
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .sort({ [sort]: order === 'desc' ? -1 : 1 })
      .select('-password'); // Exclude sensitive fields
    
    const count = await User.countDocuments();
    
    res.json({
      data: users,
      meta: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: count,
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET /api/users/:id - Get single user
router.get('/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id).select('-password');
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json({ data: user });
  } catch (error) {
    if (error.kind === 'ObjectId') {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/users - Create user
router.post('/',
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }),
    body('name').trim().notEmpty()
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    try {
      const { email, password, name } = req.body;
      
      // Check if user exists
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(409).json({ error: 'Email already registered' });
      }
      
      // Create user
      const user = await User.create({ email, password, name });
      
      res.status(201).json({
        data: {
          id: user._id,
          email: user.email,
          name: user.name
        }
      });
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
);

// PUT /api/users/:id - Update user
router.put('/:id',
  [
    body('email').optional().isEmail(),
    body('name').optional().trim().notEmpty()
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    try {
      const user = await User.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true, runValidators: true }
      ).select('-password');
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json({ data: user });
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
);

// DELETE /api/users/:id - Delete user
router.delete('/:id', async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;
```

### Versioning Question
**User:** How should I handle API versioning?

**AI:** Versioning is crucial for maintaining backward compatibility. Here are the main approaches:

**1. URL versioning (most common):**
```javascript
app.use('/api/v1/users', usersV1Router);
app.use('/api/v2/users', usersV2Router);

// URLs:
// /api/v1/users
// /api/v2/users
```

**Pros:** Clear, easy to route, cache-friendly
**Cons:** URL changes

**2. Header versioning:**
```javascript
app.use('/api/users', (req, res, next) => {
  const version = req.headers['api-version'] || 'v1';
  if (version === 'v2') {
    return usersV2Router(req, res, next);
  }
  return usersV1Router(req, res, next);
});

// Request:
// GET /api/users
// API-Version: v2
```

**Pros:** Clean URLs
**Cons:** Less visible, harder to cache

**3. Accept header (content negotiation):**
```javascript
// Request:
// GET /api/users
// Accept: application/vnd.myapi.v2+json
```

**Recommendation:** Use URL versioning for simplicity.

### Authentication Question
**User:** What's the best way to handle authentication?

**AI:** For modern APIs, JWT (JSON Web Tokens) is the standard:

**Implementation:**

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// POST /api/auth/register
router.post('/register', async (req, res) => {
  const { email, password } = req.body;
  
  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);
  
  // Create user
  const user = await User.create({
    email,
    password: hashedPassword
  });
  
  // Generate token
  const token = jwt.sign(
    { userId: user._id },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
  
  res.status(201).json({
    data: { user, token }
  });
});

// POST /api/auth/login
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Find user
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate token
  const token = jwt.sign(
    { userId: user._id },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
  
  res.json({ data: { user, token } });
});

// Authentication middleware
const auth = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

// Protected route
router.get('/profile', auth, async (req, res) => {
  const user = await User.findById(req.userId);
  res.json({ data: user });
});
```

**Client usage:**
```javascript
// Login
const response = await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password })
});
const { data } = await response.json();
localStorage.setItem('token', data.token);

// Authenticated request
fetch('/api/profile', {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});
```

### Rate Limiting Question
**User:** How do I prevent API abuse?

**AI:** Rate limiting is essential! Here's how:

```javascript
const rateLimit = require('express-rate-limit');

// General rate limit
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: 'Too many requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', limiter);

// Stricter limit for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 login attempts
  skipSuccessfulRequests: true
});

app.use('/api/auth/login', authLimiter);

// Per-user rate limiting
const userLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 10,
  keyGenerator: (req) => req.userId || req.ip
});
```

### Documentation Question
**User:** Should I document my API? How?

**AI:** Absolutely! Good documentation is crucial. Use OpenAPI (Swagger):

```javascript
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'My API',
      version: '1.0.0',
      description: 'API documentation'
    },
    servers: [
      { url: 'http://localhost:3000' }
    ]
  },
  apis: ['./routes/*.js']
};

const specs = swaggerJsdoc(options);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

// In routes file:
/**
 * @swagger
 * /api/users:
 *   get:
 *     summary: Get all users
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Success
 */
```

Visit `/api-docs` for interactive documentation!

### Key Takeaways

1. Use RESTful conventions (resources, HTTP methods)
2. Return appropriate status codes
3. Implement pagination for list endpoints
4. Validate input thoroughly
5. Use JWT for authentication
6. Implement rate limiting
7. Version your API (URL versioning recommended)
8. Document with OpenAPI/Swagger
9. Handle errors consistently
10. Never expose sensitive data

### Related Topics
- GraphQL as REST alternative
- WebSocket for real-time features
- API gateway patterns
- Microservices architecture

> This log was automatically generated from a conversation session.
