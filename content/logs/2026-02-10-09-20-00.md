---
date: 2026-02-10-09-20-00
type: daily-log
summary: "Deep dive into Git workflows and collaboration strategies"
topics: ["git", "version-control", "collaboration"]
ai_generated: true
---

# 2026-02-10-09-20-00

## Conversation: Git Workflow Strategies

### Initial Question
**User:** Our team is struggling with merge conflicts. What's the best Git workflow?

**AI:** Merge conflicts are frustrating! The right workflow depends on your team size and deployment strategy. Let me explain the main options:

**1. GitHub Flow (Simple, for continuous deployment):**
```bash
main (always deployable)
  â†“
feature branches (short-lived)
  â†“
Pull Request â†’ Review â†’ Merge to main â†’ Deploy
```

**Best for:**
- Small to medium teams
- Web applications
- Continuous deployment
- Fast iteration

**Workflow:**
```bash
# Create feature branch
git checkout -b feature/add-login

# Work and commit
git add .
git commit -m "feat: add login form"

# Push and create PR
git push origin feature/add-login

# After review, merge to main
# Automatic deployment from main
```

**2. Git Flow (Complex, for scheduled releases):**
```bash
main (production)
  â†“
develop (integration)
  â†“
feature/* (new features)
release/* (release prep)
hotfix/* (urgent fixes)
```

**Best for:**
- Large teams
- Scheduled releases
- Multiple versions in production
- Enterprise software

**3. Trunk-Based Development (Fast, for experienced teams):**
```bash
main (trunk)
  â†“
short-lived branches (< 2 days)
  â†“
Merge frequently, use feature flags
```

**Best for:**
- Experienced teams
- High deployment frequency
- Strong CI/CD pipeline

### Follow-up Question
**User:** We're a team of 5 working on a web app. Which should we use?

**AI:** For your situation, I recommend **GitHub Flow**. Here's why:

**Advantages:**
- Simple to understand and follow
- Encourages small, frequent changes
- Main branch always deployable
- Fast feedback through PRs

**Implementation:**

**1. Branch naming convention:**
```bash
feature/user-authentication
bugfix/login-error
hotfix/critical-security-patch
docs/api-documentation
refactor/database-layer
```

**2. Commit message format (Conventional Commits):**
```bash
<type>(<scope>): <subject>

feat(auth): add OAuth2 login
fix(api): handle null user response
docs(readme): update installation steps
refactor(utils): simplify date formatting
test(auth): add login integration tests
```

**3. PR workflow:**
```bash
# Update main
git checkout main
git pull origin main

# Create feature branch
git checkout -b feature/search-functionality

# Make changes
git add .
git commit -m "feat(search): implement full-text search"

# Keep branch updated
git fetch origin
git rebase origin/main

# Push and create PR
git push origin feature/search-functionality
```

### Conflict Resolution Question
**User:** How do I handle merge conflicts when they happen?

**AI:** Great question! Here's a systematic approach:

**1. Update your branch regularly:**
```bash
# While working on feature branch
git fetch origin
git rebase origin/main

# If conflicts occur
# Edit conflicted files
git add resolved-file.js
git rebase --continue
```

**2. Understanding conflict markers:**
```javascript
<<<<<<< HEAD (your changes)
const greeting = "Hello World";
=======
const greeting = "Hi there";
>>>>>>> feature/branch (incoming changes)
```

**Resolution strategies:**
- Keep your changes: Delete markers and incoming code
- Keep incoming: Delete markers and your code
- Combine both: Merge logic from both versions
- Rewrite: Create new solution

**3. Tools to help:**
```bash
# Use visual merge tool
git mergetool

# VS Code has excellent built-in conflict resolution
# Shows "Accept Current", "Accept Incoming", "Accept Both"
```

**4. Prevent conflicts:**
- Keep branches short-lived (< 3 days)
- Pull/rebase frequently
- Communicate with team about file changes
- Split large files into smaller modules

### Code Review Question
**User:** What makes a good code review process?

**AI:** Excellent question! Code reviews are crucial for quality. Here's a complete process:

**For Authors:**

**1. Before creating PR:**
```bash
# Self-review checklist
- [ ] Code works and is tested
- [ ] Follows team style guide
- [ ] No console.logs or debug code
- [ ] Comments explain "why", not "what"
- [ ] No sensitive data (keys, passwords)
```

**2. PR description template:**
```markdown
## What does this PR do?
Brief description of changes

## Type of change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## How to test
1. Step-by-step testing instructions
2. Expected behavior

## Screenshots (if UI changes)

## Checklist
- [ ] Tests pass locally
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
```

**3. Keep PRs small:**
```bash
# Bad: 50 files, 2000 lines changed
# Good: 5 files, 200 lines changed

# If feature is large, break into multiple PRs
PR 1: Database schema
PR 2: API endpoints
PR 3: Frontend components
PR 4: Integration
```

**For Reviewers:**

**1. Review promptly (within 24 hours)**

**2. Be constructive:**
```
# Bad
"This code is terrible"

# Good
"Consider extracting this logic into a separate function for better testability"
```

**3. Use review comments effectively:**
```
ðŸ’¡ Suggestion: Optional improvement
â“ Question: Need clarification
ðŸ› Bug: Potential issue
ðŸ”’ Security: Security concern
âš¡ Performance: Performance issue
```

**4. Approve when satisfied:**
```bash
# After review
- Request changes (if issues found)
- Approve (if looks good)
- Comment (if just suggestions)
```

### Advanced Git Techniques
**User:** What are some advanced Git tricks that can help?

**AI:** Here are powerful techniques:

**1. Interactive rebase (clean up commits):**
```bash
# Rebase last 3 commits
git rebase -i HEAD~3

# Options:
pick abc123 Add feature
squash def456 Fix typo
reword ghi789 Update tests

# Result: 3 commits â†’ 1 clean commit
```

**2. Stash (save work in progress):**
```bash
# Save current work
git stash save "WIP: implementing search"

# Switch branches
git checkout main

# Come back and restore
git checkout feature/search
git stash pop
```

**3. Cherry-pick (apply specific commit):**
```bash
# Apply commit from another branch
git cherry-pick abc123

# Useful for hotfixes
```

**4. Bisect (find bug-introducing commit):**
```bash
git bisect start
git bisect bad  # Current version has bug
git bisect good v1.0  # v1.0 was working

# Git checks out middle commit
# Test and mark as good or bad
git bisect good  # or bad

# Repeat until bug found
git bisect reset
```

**5. Reflog (recover lost commits):**
```bash
# View all ref changes
git reflog

# Recover deleted branch
git checkout -b recovered-branch abc123
```

**6. Aliases (save time):**
```bash
# Add to ~/.gitconfig
[alias]
  co = checkout
  br = branch
  ci = commit
  st = status
  unstage = reset HEAD --
  last = log -1 HEAD
  lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
  undo = reset HEAD~1 --mixed
  amend = commit --amend --no-edit
```

### Team Collaboration Best Practices
**User:** Any other tips for smooth team collaboration?

**AI:** Absolutely! Here are essential practices:

**1. Protected branches:**
```
Settings â†’ Branches â†’ Add rule for main:
- Require pull request reviews (2 approvers)
- Require status checks to pass
- Require branches to be up to date
- Restrict who can push
```

**2. Code owners:**
```
# .github/CODEOWNERS
* @team-lead

/frontend/** @frontend-team
/backend/** @backend-team
/docs/** @tech-writers

package.json @team-lead
```

**3. Git hooks (automate checks):**
```bash
# .husky/pre-commit
npm run lint
npm test
```

**4. Communication:**
- Link PRs to issues: "Closes #123"
- Use draft PRs for early feedback
- Comment on specific lines in PR
- Use GitHub discussions for decisions

**5. Documentation:**
- Keep README updated
- Document setup steps
- Explain architecture decisions
- Maintain CHANGELOG.md

### Key Takeaways

1. Choose workflow based on team size and deployment frequency
2. GitHub Flow works well for most web applications
3. Keep branches short-lived to minimize conflicts
4. Rebase frequently to stay updated
5. Write clear commit messages (Conventional Commits)
6. Keep PRs small (< 400 lines)
7. Review code promptly and constructively
8. Use protected branches and code owners
9. Automate checks with Git hooks
10. Communicate clearly in PRs and commits

### Related Topics
- CI/CD pipeline integration
- Semantic versioning
- Release management
- Git LFS for large files

> This log was automatically generated from a conversation session.
