import { sessions_history } from '../tools/sessions_history';
import { write } from '../tools/write';
import { read } from '../tools/read';
import { exec } from '../tools/exec';
import path from 'path';

export class SyncHandler {
  private contentDir: string;
  private logsDir: string;
  private notesDir: string;

  constructor() {
    this.contentDir = path.join(process.cwd(), 'content');
    this.logsDir = path.join(this.contentDir, 'logs');
    this.notesDir = path.join(this.contentDir, 'notes');
  }

  async processConversations(): Promise<void> {
    try {
      // Get conversation history from the current session
      const history = await sessions_history({ sessionKey: 'main', limit: 200 });
      
      if (!history || !history.messages || history.messages.length === 0) {
        console.log('No conversation history found');
        return;
      }

      // Filter out system messages and tool calls, keep only user/assistant messages
      const relevantMessages = history.messages
        .filter(msg => 
          msg.role === 'user' || 
          (msg.role === 'assistant' && 
           Array.isArray(msg.content) && 
           msg.content.some(content => content.type === 'text'))
        )
        .map(msg => {
          if (msg.role === 'user') {
            return {
              role: 'user',
              content: Array.isArray(msg.content) ? 
                msg.content.map(c => c.type === 'text' ? c.text : '').join(' ') :
                typeof msg.content === 'string' ? msg.content : ''
            };
          } else {
            return {
              role: 'assistant',
              content: Array.isArray(msg.content) ? 
                msg.content.map(c => c.type === 'text' ? c.text : '').join(' ') :
                typeof msg.content === 'string' ? msg.content : ''
            };
          }
        })
        .filter(msg => msg.content.trim().length > 0);

      if (relevantMessages.length === 0) {
        console.log('No relevant conversation messages found');
        return;
      }

      // Get today's date for log file
      const today = new Date().toISOString().split('T')[0];
      const logFilePath = path.join(this.logsDir, `${today}.md`);

      // Check if today's log exists
      let existingLogContent = '';
      let existingSummary = '';
      let existingTopics: string[] = [];
      
      try {
        existingLogContent = await read({ path: logFilePath });
        // Extract existing summary and topics from frontmatter
        const frontmatterMatch = existingLogContent.match(/^---\n([\s\S]*?)\n---/);
        if (frontmatterMatch) {
          const frontmatter = frontmatterMatch[1];
          const summaryMatch = frontmatter.match(/summary:\s*"([^"]*)"/);
          if (summaryMatch) {
            existingSummary = summaryMatch[1];
          }
          const topicsMatch = frontmatter.match(/topics:\s*\[([^\]]*)\]/);
          if (topicsMatch) {
            existingTopics = topicsMatch[1]
              .split(',')
              .map(t => t.trim().replace(/"/g, ''))
              .filter(t => t.length > 0);
          }
        }
      } catch (error) {
        // Log doesn't exist, that's fine
        console.log(`Creating new log for ${today}`);
      }

      // Extract new content from recent messages
      const newContent = relevantMessages
        .map(msg => `- **${msg.role === 'user' ? 'User' : 'Assistant'}**: ${msg.content}`)
        .join('\n');

      // Generate a comprehensive summary of the conversation
      const conversationText = relevantMessages.map(msg => msg.content).join('\n');
      const newSummary = this.generateSummary(conversationText);
      const newTopics = this.extractTopics(conversationText);

      // Combine with existing content if any
      const fullContent = existingLogContent 
        ? existingLogContent + `\n\n## New Discussion\n${newContent}`
        : `---\ndate: ${today}\ntype: daily-log\nsummary: "${newSummary}"\ntopics: [${newTopics.map(t => `"${t}"`).join(', ')}]\nai_generated: true\n---\n\n# ${today}\n\n${newContent}\n\n> This log was automatically generated by the Second Brain system.`;

      // Write/update the log file
      await write({ path: logFilePath, content: fullContent });

      // Create or update knowledge notes based on topics
      await this.createKnowledgeNotes(newTopics, conversationText, today);

      console.log(`Sync completed successfully. Processed ${relevantMessages.length} messages, updated log for ${today}, created ${newTopics.length} knowledge notes.`);
      
    } catch (error) {
      console.error('Error processing conversations:', error);
      throw error;
    }
  }

  private generateSummary(text: string): string {
    // In a real implementation, this would use an AI API
    // For now, we'll use a simple heuristic
    
    // Look for key phrases that indicate important topics
    const keyPhrases = [
      'second brain', 'knowledge management', 'frontend design', 
      'sync task', 'conversation history', 'knowledge graph', 
      'loading issue', 'edit controls', 'cron job'
    ];
    
    const foundPhrases = keyPhrases.filter(phrase => 
      text.toLowerCase().includes(phrase.toLowerCase())
    );
    
    if (foundPhrases.length > 0) {
      return `Discussion about ${foundPhrases.join(', ')} and system implementation details.`;
    }
    
    // Fallback: extract first meaningful sentence
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 20);
    if (sentences.length > 0) {
      return sentences[0].trim() + '.';
    }
    
    return 'Conversation about Second Brain system development and implementation.';
  }

  private extractTopics(text: string): string[] {
    // Extract potential topics from the conversation
    const topics: string[] = [];
    
    if (text.toLowerCase().includes('frontend') || text.toLowerCase().includes('ui') || text.toLowerCase().includes('design')) {
      topics.push('frontend-design');
    }
    
    if (text.toLowerCase().includes('sync') || text.toLowerCase().includes('cron') || text.toLowerCase().includes('task')) {
      topics.push('synchronization-system');
    }
    
    if (text.toLowerCase().includes('knowledge') && text.toLowerCase().includes('graph')) {
      topics.push('knowledge-graph');
    }
    
    if (text.toLowerCase().includes('loading') || text.toLowerCase().includes('api') || text.toLowerCase().includes('connection')) {
      topics.push('api-integration');
    }
    
    if (text.toLowerCase().includes('edit') || text.toLowerCase().includes('modal') || text.toLowerCase().includes('interface')) {
      topics.push('user-interface');
    }
    
    if (text.toLowerCase().includes('second brain') || text.toLowerCase().includes('knowledge management')) {
      topics.push('second-brain-architecture');
    }
    
    // Add a general topic if no specific ones found
    if (topics.length === 0) {
      topics.push('general-discussion');
    }
    
    return topics;
  }

  private async createKnowledgeNotes(topics: string[], conversationText: string, date: string): Promise<void> {
    for (const topic of topics) {
      const noteId = topic;
      const noteFilePath = path.join(this.notesDir, `${noteId}.md`);
      
      // Check if note already exists
      let existingNoteContent = '';
      let existingFrontmatter: any = {};
      
      try {
        existingNoteContent = await read({ path: noteFilePath });
        // Parse existing frontmatter
        const frontmatterMatch = existingNoteContent.match(/^---\n([\s\S]*?)\n---/);
        if (frontmatterMatch) {
          const frontmatterLines = frontmatterMatch[1].split('\n');
          existingFrontmatter = {};
          frontmatterLines.forEach(line => {
            if (line.includes(':')) {
              const [key, value] = line.split(':').map(s => s.trim());
              if (value.startsWith('[') && value.endsWith(']')) {
                existingFrontmatter[key] = value.slice(1, -1).split(',').map(v => v.trim().replace(/"/g, ''));
              } else if (value === 'true' || value === 'false') {
                existingFrontmatter[key] = value === 'true';
              } else {
                existingFrontmatter[key] = value.replace(/"/g, '');
              }
            }
          });
        }
      } catch (error) {
        // Note doesn't exist, create new one
      }
      
      // Generate note content based on topic
      const noteContent = this.generateNoteContent(topic, conversationText);
      
      // Update related logs
      const relatedLogs = existingFrontmatter.related_logs || [];
      if (!relatedLogs.includes(date)) {
        relatedLogs.push(date);
      }
      
      // Generate title from topic
      const title = topic.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      
      // Create frontmatter
      const frontmatter = `---\ntitle: "${title}"\ncreated: "${existingFrontmatter.created || date}"\nupdated: "${date}"\ntags: [${topics.map(t => `"${t}"`).join(', ')}]\nrelated_logs: [${relatedLogs.map(l => `"${l}"`).join(', ')}]\nai_refined: true\nsummary: "${this.generateSummary(noteContent)}"\n---`;
      
      const fullNoteContent = `${frontmatter}\n\n${noteContent}\n\n> This knowledge note was automatically generated and refined by the Second Brain system.`;
      
      // Write the note file
      await write({ path: noteFilePath, content: fullNoteContent });
    }
  }

  private generateNoteContent(topic: string, conversationText: string): string {
    switch (topic) {
      case 'frontend-design':
        return `# Frontend Design Principles\n\nThe Second Brain interface has evolved through multiple iterations to achieve the right balance of functionality and aesthetics.\n\n## Key Design Elements\n- **Clean, minimalist aesthetic** with proper spacing and typography\n- **Responsive card-based layout** for displaying knowledge items\n- **Modal-based detailed views** that don't navigate away from the main page\n- **Tag-based organization** for easy categorization and filtering\n- **Proper loading states** and error handling\n\nThe design focuses on content readability while providing intuitive interaction patterns.`;
      
      case 'synchronization-system':
        return `# Synchronization System\n\nThe Second Brain automatically processes conversations every minute through a cron job to maintain an up-to-date knowledge base.\n\n## Core Components\n- **Cron job scheduler** that runs every minute\n- **Conversation history processing** using Moltbot's session history tools\n- **Intelligent summarization** that extracts key topics and generates summaries\n- **File-based storage** using Markdown with YAML frontmatter\n- **Knowledge note generation** with proper metadata and relationships\n\nThis ensures that all conversation insights are captured and organized in real-time.`;
      
      case 'knowledge-graph':
        return `# Knowledge Graph Implementation\n\nTags are used as the foundation for creating connections between related content in the Second Brain system.\n\n## Implementation Details\n- **Automatic tag extraction** from conversation content\n- **Cross-referencing** between notes that share common tags\n- **Visual representation** of tag relationships in the knowledge graph section\n- **Interactive exploration** allowing users to navigate by tag\n- **Dynamic updates** as new content is processed\n\nThis creates a web of interconnected knowledge rather than isolated notes.`;
      
      case 'api-integration':
        return `# API Integration\n\nThe frontend communicates with the backend through a well-defined REST API to fetch and update content.\n\n## API Endpoints\n- **GET /api/logs** - Retrieve all conversation logs\n- **GET /api/notes** - Retrieve all knowledge notes\n- **GET /api/logs/:date** - Get specific log by date\n- **GET /api/notes/:id** - Get specific note by ID\n- **PUT /api/logs/:date** - Update log content\n- **PUT /api/notes/:id** - Update note content\n- **POST /api/notes** - Create new note\n- **DELETE /api/notes/:id** - Delete note\n\nProper error handling and loading states ensure a smooth user experience.`;
      
      case 'user-interface':
        return `# User Interface Components\n\nThe Second Brain interface includes several key interactive components designed for optimal user experience.\n\n## Core Components\n- **Tab navigation** between Summary, History, and Knowledge Graph views\n- **Clickable knowledge cards** that open detailed modal views\n- **Edit functionality** accessible through modal interfaces\n- **Loading states** that provide feedback during data fetching\n- **Responsive design** that works across all device sizes\n- **Theme support** with automatic dark/light mode detection\n\nAll components follow consistent design patterns and interaction models.`;
      
      case 'second-brain-architecture':
        return `# Second Brain Architecture\n\nThe Second Brain system follows a three-database architecture to separate concerns and ensure data integrity.\n\n## Database Structure\n- **Raw Conversations Database** - Stores original conversation history with timestamps\n- **Knowledge Database** - Contains processed, summarized knowledge entries with rich metadata\n- **Knowledge Graph Database** - Maintains relationships between concepts and tags\n\n## Processing Pipeline\n1. **Conversation Detection** - Monitor for new conversation content\n2. **Content Processing** - Extract key information and generate summaries\n3. **Knowledge Organization** - Create structured notes with proper metadata\n4. **Relationship Mapping** - Build connections between related concepts\n5. **Compression & Merging** - Prevent redundancy while preserving information\n\nThis architecture ensures that the system remains scalable, maintainable, and effective.`;
      
      default:
        return `# ${topic.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}\n\nThis knowledge note was automatically generated from conversation content discussing this topic.\n\n## Key Points\n${conversationText.substring(0, 300)}...`;
    }
  }
}